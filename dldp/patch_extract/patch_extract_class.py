#!/home/wli/env python3
# -*- coding: utf-8 -*-
"""
Title: patch extractor class
============================

Created: 11-30-2019
Python-Version: 3.5
Status: under development

Description:
------------

This libray module provides a class for patch extraction. Its function is the same
as the module Patch_Extractor.

Note:
-----
This module is still under developing.

"""


import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from PIL import Image
import os.path as osp
import openslide
from pathlib import Path

# scipy.misc.imsave is deprecated! imsave is deprecated in SciPy 1.0.0,
# and will be removed in 1.2.0. Use imageio.imwrite instead.
#from scipy.misc import imsave as saveim
from imageio import imwrite as saveim
from skimage.filters import threshold_otsu
import glob
# before importing HDFStore, make sure 'tables' is installed by pip3 install tables
from pandas import HDFStore
from openslide.deepzoom import DeepZoomGenerator
import cv2 as cv2
from skimage import io
import xml.etree.ElementTree as et
import pandas as pd
import math
import os


# go through all the file
def slides_for_patch_extraction(slide_folder, file_ext):
    """
    This function is to generate a list for all the slides in a folder.

    :param slide_folder: a folder storing WSI images.
    :type slide_folder: string
    :param file_ext: file type, for exaple, "tif"
    :type file_ext: string

    :return: slide_paths
    :rtype: a list including all the obsolute paths of the slides from a
            folder.

    """
    slide_paths = glob.glob(osp.join(slide_folder, '*.%s' % file_ext))
    slide_paths.sort()
    return slide_paths


def create_folder(single_slide_for_patch_extraction, destination_folder):
    """
    The function is used to create folder and store image patches. All the
    image patches extracted from the same slide will be saved in the same
    folder.

    :param single_slide_for_patch_extraction: the slide used to get image
                                            patches
    :type single_slide_for_patch_extraction: str
    :param destination_folder: the place to store all the extracted image
                            patches
    :return: the folder to be created
    :rtype: str

    """
    print(single_slide_for_patch_extraction)
    print(osp.splitext(osp.basename(single_slide_for_patch_extraction)))
    folder_to_create = osp.splitext(
        osp.basename(single_slide_for_patch_extraction))[0]
    print(folder_to_create)
    path_for_folder = osp.join(destination_folder, folder_to_create)
    print(path_for_folder)
    try:
        os.makedirs(path_for_folder)
    except Exception:
        print('folder exist, skipped')

    return path_for_folder


class patch_extract(object):
    """
    The class is used to extract image patches from a single WSI image.
    The WSI image and its ground truth (if tumor) have to be read by
    OpenSlide as projects.

    :param slide: object generated by openslide
    :type slide: object
    :param ground_truth: the object generated by openslide
    :type ground_truth: object
    :param crop_size: the size of image patches to be extracted
    :type crop_size: list
    :param des_folder_patches: the folder to store the extracted patches
    :type des_folder_patches: string
    :param des_folder_mask: the folder to store the extracted
                                            ground truth
    :param des_folder_mask: string
    :param anno_dir: the folder storing all the xml files
    :type anno_dir: string
    :param single_slide_for_patch_extraction: the path of a WSI slide
    :type single_slide_for_patch_extraction: string

    :ivar thresh: the threshhold for tissue region
    :type thresh: list
    :ivar bbox_tissue: the bounding box for tissue region
    :type bbox_tissue: tuple

    :note: The extracted image patches will be saved.
    """

    def __init__(self, slide, crop_size, des_folder_patches,
                 single_slide_for_patch_extraction,
                 anno_dir=False, ground_truth=False, des_folder_mask=False):

        self.slide = slide
        self.crop_size = crop_size
        self.des_folder_patches = des_folder_patches
        self.anno_dir = anno_dir
        self.ground_truth = ground_truth
        self.des_folder_mask = des_folder_mask

    def __hsv_thumbnail(self):
        """
        generate a HSV thumbnail image for WSI image with downsample of 32.
        The ratio of length and width of the image is still the same as the
        level 0 image.

        :return: hsv image
        :rtype: array

        """
        thumbnail = self.slide.get_thumbnail(
            (self.slide.dimensions[0] / 32, self.slide.dimensions[1] / 32))
        thum = np.array(thumbnail)
        hsv_image = cv2.cvtColor(thum, cv2.COLOR_RGB2HSV)
        return hsv_image

    def __convert_xml_df(self):
        """
        convert the xml file to a list of coordinates

        :returns: coordinates
        :rtype: tuple including all the coordinates

        """
        parseXML = et.parse(self.anno_dir)
        root = parseXML.getroot()
        dfcols = ['Name', 'Order', 'X', 'Y']
        df_xml = pd.DataFrame(columns=dfcols)
        for child in root.iter('Annotation'):
            for coordinate in child.iter('Coordinate'):
                Name = child.attrib.get('Name')
                Order = coordinate.attrib.get('Order')
                X_coord = float(coordinate.attrib.get('X'))
                # X_coord = X_coord - 30000
                # X_coord = ((X_coord)*dims[0])/Ximageorg
                Y_coord = float(coordinate.attrib.get('Y'))
                # Y_coord = Y_coord - 155000
                # Y_coord = ((Y_coord)*dims[1])/Yimageorg
                df_xml = df_xml.append(
                    pd.Series([Name, Order, X_coord, Y_coord], index=dfcols),
                    ignore_index=True)
                df_xml = pd.DataFrame(df_xml)
        return (df_xml)

    def tissue_patch_threshold(self):
        """
        get a threshold for tissue region

        :returns: threshold
        :rtype: list

        """
        hsv_image = self.__hsv_thumbnail(self.slide)
        h, s, v = cv2.split(hsv_image)
        hthresh = threshold_otsu(h)
        sthresh = threshold_otsu(s)
        vthresh = threshold_otsu(v)
        # be min value for v can be changed later
        minhsv = np.array([hthresh, sthresh, 70], np.uint8)
        maxhsv = np.array([180, 255, vthresh], np.uint8)
        thresh = [minhsv, maxhsv]
        return thresh

    def bbox_generation_tissue(self):
        """
        generate a bounding box for tissue region in a WSI image

        :returns: bbox_tissue, the coordinates for the four corners of
                the tissue region.
        :rtype: tuple

        """
        hsv_image = self.__hsv_thumbnail(self.slide)
        # h, s, v = cv2.split(hsv_image)
        # hthresh = threshold_otsu(h)
        # sthresh = threshold_otsu(s)
        # vthresh = threshold_otsu(v)
        # be min value for v can be changed later
        # minhsv = np.array([hthresh, sthresh, 70], np.uint8)
        # maxhsv = np.array([180, 255, vthresh], np.uint8)
        # thresh = [minhsv, maxhsv]
        thresh = self.tissue_patch_threshold(self.slide)
        # extraction the countor for tissue

        rgbbinary = cv2.inRange(hsv_image, thresh[0], thresh[1])
        _, contours, _ = cv2.findContours(
            rgbbinary, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
        bboxtcols = ['xmin', 'xmax', 'ymin', 'ymax']
        bboxt = pd.DataFrame(columns=bboxtcols)
        for c in contours:
            (x, y, w, h) = cv2.boundingRect(c)
            bboxt = bboxt.append(
                pd.Series([x, x + w, y, y + h], index=bboxtcols),
                ignore_index=True)
            bboxt = pd.DataFrame(bboxt)

        xxmin = list(bboxt['xmin'].get_values())
        xxmax = list(bboxt['xmax'].get_values())
        yymin = list(bboxt['ymin'].get_values())
        yymax = list(bboxt['ymax'].get_values())
        bbox_tissue = math.floor(np.min(xxmin) * 32),
        math.floor(np.max(xxmax) * 32), math.floor(
            np.min(yymin) * 32), math.floor(np.max(yymax) * 32)
        return (bbox_tissue, thresh)

    def bbox_generation_tumor(self):
        """
        generate a bounding box for tumor region. If several regions exist,
        a big bounding box will be generated to include all the regions.

        :returns: bbox_tumor, the coordinates for the four corners of
                the tumor region.
        :rtype: tuple

        """
        Anno_path_xml = osp.join(self.anno_dir, osp.basename(
            self.single_slide_for_patch_extraction).replace('.tif', '.xml'))

        # slide = openslide.open_slide(single_slide_for_patch_extraction)
        annotations = self.__convert_xml_df(str(Anno_path_xml))
        x_values = list(annotations['X'].get_values())
        y_values = list(annotations['Y'].get_values())
        bbox_tumor = math.floor(
            np.min(x_values)), math.floor(np.max(x_values)),
        math.floor(
            np.min(y_values)), math.floor(
            np.max(y_values))
        return bbox_tumor

    def random_crop_tumor_tumor(self):
        """
        generate image patches from a WSI image
        :returns: rgb_image, rgb_binary, rgb_mask, index
        :rtype: tuple

        """
        # width, height = slide.level_dimensions[0]
        dy, dx = self.crop_size
        bbox_tumor = self.bbox_generation_tumor()
        thresh = self.tissue_patch_threshold()
        x = np.random.randint(bbox_tumor[0], bbox_tumor[1] - dx + 1)
        y = np.random.randint(bbox_tumor[2], bbox_tumor[3] - dy + 1)
        # x = np.random.choice(range(width - dx + 1), replace = False)
        # y = np.random.choice(range(height - dy +1), replace = False)
        index = [x, y]
        # print(index)
        # cropped_img = (image[x:(x+dx), y:(y+dy),:], rgb_binary[x:(x+dx), y:(y+dy)], mask[x:(x+dx), y:(y+dy)])
        rgb_image = self.slide.read_region((x, y), 0, self.crop_size)
        rgb_mask = self.truth.read_region((x, y), 0, self.crop_size)
        rgb_mask = (cv2.cvtColor(np.array(rgb_mask),
                                 cv2.COLOR_RGB2GRAY) > 0).astype(int)
        rgb_array = np.array(rgb_image)
        hsv_rgbimage = cv2.cvtColor(rgb_array, cv2.COLOR_RGB2HSV)
        rgb_binary = cv2.inRange(hsv_rgbimage, thresh[0], thresh[1])
        # cropped_img = image[x:(x+dx), y:(y+dy),:]
        # cropped_binary = rgb_binary[x:(x+dx), y:(y+dy)]
        # cropped_mask = mask[x:(x+dx), y:(y+dy)]
        print(index)
        return (rgb_image, rgb_binary, rgb_mask, index)

    # random_crop_tumor_normal is not nessary.

    def random_crop_tumor_normal(self):
        """
        The major function to extract image patches from WSI images together with
        ground truth. This function is used for tumor patch extraction with its
        ground truth.

        :returns: rgb_image, rgb_binary, rgb_mask, index
        :rtype: tuple

        """
        # width, height = slide.level_dimensions[0]
        dy, dx = self.crop_size
        bboxt, thresh = self.bbox_generation_tissue()

        x = np.random.randint(bboxt[0], bboxt[1] - dx + 1)
        y = np.random.randint(bboxt[2], bboxt[3] - dy + 1)
        # x = np.random.choice(range(width - dx + 1), replace = False)
        # y = np.random.choice(range(height - dy +1), replace = False)
        index = [x, y]
        # print(index)
        # cropped_img = (image[x:(x+dx), y:(y+dy),:], rgb_binary[x:(x+dx), y:(y+dy)], mask[x:(x+dx), y:(y+dy)])
        rgb_image = self.slide.read_region((x, y), 0, self.crop_size)
        rgb_mask = self.truth.read_region((x, y), 0, self.crop_size)
        rgb_mask = (cv2.cvtColor(np.array(rgb_mask),
                                 cv2.COLOR_RGB2GRAY) > 0).astype(int)
        rgb_array = np.array(rgb_image)
        hsv_rgbimage = cv2.cvtColor(rgb_array, cv2.COLOR_RGB2HSV)
        rgb_binary = cv2.inRange(hsv_rgbimage, thresh[0], thresh[1])
        # cropped_img = image[x:(x+dx), y:(y+dy),:]
        # cropped_binary = rgb_binary[x:(x+dx), y:(y+dy)]
        # cropped_mask = mask[x:(x+dx), y:(y+dy)]
        print(index)
        return (rgb_image, rgb_binary, rgb_mask, index)

    def random_crop_normal(self):
        """
        The major function for image patch generation. This function is used to get
        image patches from normal WSI slides.

        :returns: rgb_image, rgb_binary, index
        :rtype: tuple

        """
        # width, height = slide.level_dimensions[0]
        dy, dx = self.crop_size
        bbox_tissue, thresh = self.bbox_generation_tissue()
        x = np.random.randint(bbox_tissue[0], bbox_tissue[1] - dx + 1)
        y = np.random.randint(bbox_tissue[2], bbox_tissue[3] - dy + 1)
        index = [x, y]
        # cropped_img = (image[x:(x+dx), y:(y+dy),:], rgb_binary[x:(x+dx), y:(y+dy)], mask[x:(x+dx), y:(y+dy)])
        rgb_image = self.slide.read_region((x, y), 0, self.crop_size)
        # rgb_mask = truth.read_region((x, y), 0, crop_size)
        # rgb_mask = (cv2.cvtColor(np.array(mask), cv2.COLOR_RGB2GRAY) > 0).astype(int)
        # rgb_grey = np.array(rgb_image.convert('L'))
        # rgb_binary = (rgb_grey < thresh).astype(int)
        rgb_array = np.array(rgb_image)
        hsv_rgbimage = cv2.cvtColor(rgb_array, cv2.COLOR_RGB2HSV)
        rgb_binary = cv2.inRange(hsv_rgbimage, thresh[0], thresh[1])
        # cropped_img = image[x:(x+dx), y:(y+dy),:]
        # cropped_binary = rgb_binary[x:(x+dx), y:(y+dy)]
        # cropped_mask = mask[x:(x+dx), y:(y+dy)]
        return (rgb_image, rgb_binary, index)

    @staticmethod
    def testduplicates(list):
        """
        get rid of duplicate entries

        :param list: the list for duplication checking
        :type list: list
        :returns: the list with no duplication
        :rtype: list

        """
        for each in list:
            count = list.count(each)
            if count > 1:
                z = 0
            else:

                z = 1
        return z

    # sampletotal = pd.DataFrame([])

    def extract_normal_patches_from_normal_slide(self):
        """
        The actual function for patch extraction from normal slides.

        """
        o = 0
        while o in range(0, 1000):
            nr = self.random_crop_normal()
            if (cv2.countNonZero(nr[1]) > self.crop_size[0] * self.crop_size[1] * 0.1) and (o <= 1000):
                nmask = np.zeros((256, 256))

                saveim('%s/%s_%d_%d_N.png' % (self.des_folder_patches,
                                              osp.splitext(osp.basename(
                                                  self.single_slide_for_patch_extraction))[0], nr[2][0], nr[2][1]), nr[0])
                # io.imsave('/home/wli/Downloads/test/nmask/%s_%d_%d_mask.png' % (
                # osp.splitext(osp.basename(slide_paths_total[i]))[0], nr[2][0], nr[2][1]), nmask)

                # c.append(r[3])

                # zzz = testduplicates(c)
                o = o + 1

            else:
                o = o

    def extract_tumor_patches_from_tumor_slide(self):
        """
        The actual function for tumor patch extraction from tumor slides.

        """
        m = 0
        # a = []
        while m in range(0, 1000):
            r = self.random_crop_tumor_tumor()
            if (cv2.countNonZero(r[2]) > self.crop_size[0] * self.crop_size[1] * 0.5) and (m <= 1000):

                saveim('%s/%s_%d_%d_T.png' % (self.des_folder_patches,
                                              osp.splitext(osp.basename(self.single_slide_for_patch_extraction))[0], r[3][0], r[3][1]), r[0])

                io.imsave('%s/%s_%d_%d_T_mask.png' % (self.des_folder_mask,
                                                      osp.splitext(osp.basename(self.single_slide_for_patch_extraction))[0], r[3][0], r[3][1]), r[2])

                print(r[2])

                # a.append(r[3])
                # z = testduplicates(a)
                m = m + 1

            else:
                m = m

    def extract_normal_patches_from_tumor_slide(self):
        """

        The actual function for tumor patch extraction from tumor slides.

        """
        n = 0
        # b=[]
        while n in range(0, 1000):
            # slide = openslide.open_slide(slide_paths[i])
            r = self.random_crop_tumor_normal()
            if (cv2.countNonZero(r[1]) > self.crop_size[0] * self.crop_size[1] * 0.1) and (cv2.countNonZero(r[2]) == 0) and (
                    n <= 1000):

                saveim('%s/%s_%d_%d_N.png' % (self.des_folder_patches,
                                              osp.splitext(osp.basename(self.single_slide_for_patch_extraction))[0], r[3][0], r[3][1]), r[0])
                # io.imsave('/home/wli/Downloads/test/validation/nmask/%s_%d_%d_mask.png' % (
                # osp.splitext(osp.basename(slide_paths_total[i]))[0], r[3][0], r[3][1]), r[2])

                # b.append(r[3])
                # zz = testduplicates(b)

                n = n + 1

            else:
                n = n


if __name__ == "__main__":

    slide_path_tumor = '/home/wli/Downloads/CAMELYON16/training/tumor'
    mask_dirs = '/home/wli/Downloads/CAMELYON16/masking'
    anno_dir = '/home/wli/Downloads/CAMELYON16/training/Lesion_annotations'

    destination_folder_normal = '/raidb/wli/tumor_slide_normal_256'
    destination_folder_tumor = '/raidb/wli/tumor_slide_tumor_256'
    destination_folder_tumor_mask = '/raidb/wli/tumor_slide_tumor_256_mask'

    tumor_slide_paths = slides_for_patch_extraction(slide_path_tumor)

    crop_size = [256, 256]
    slide_path_for_extraction = tumor_slide_paths
    # while loop is used here because 2-3 slides have very samll tumor region. It is
    # impossible to extract 1000 patches. The loop need to stop mannually and move
    # to next slide.
    i = 0
    while i < len(slide_path_for_extraction):

        single_slide_for_patch_extraction = slide_path_for_extraction[i]
        des_folder_normal_patches = create_folder(
            single_slide_for_patch_extraction, destination_folder_normal)
        des_folder_tumor_patches = create_folder(
            single_slide_for_patch_extraction, destination_folder_tumor)
        des_folder_tumor_patches_mask = create_folder(
            single_slide_for_patch_extraction, destination_folder_tumor_mask)
        # sampletotal = pd.DataFrame([])single_slide_for_patch_extraction
        slide = openslide.open_slide(single_slide_for_patch_extraction)
        mask_path = osp.join(mask_dirs, osp.basename(
            single_slide_for_patch_extraction).replace('.tif', '_mask.tif'))
        ground_truth = openslide.open_slide(str(mask_path))

        tumor_patch_extractor = patch_extract(slide, crop_size,
                                              des_folder_tumor_patches,
                                              single_slide_for_patch_extraction,
                                              anno_dir, ground_truth,
                                              destination_folder_tumor_mask)
        tumor_patch_extractor.extract_tumor_patches_from_tumor_slide()
        normal_patch_extractor = patch_extract(slide, crop_size,
                                               des_folder_normal_patches,
                                               single_slide_for_patch_extraction)
        normal_patch_extractor.extract_normal_patches_from_tumor_slide()

        i += 1
